Newsqueak2
'LangexplrExperiments'

class JSParser withParserLib: parserLibrary usingLib: platform =  (
"Experiment for JS parser based on the description from http://www.json.org/fatfree.html "
|
	ExecutableGrammar = parserLibrary ExecutableGrammar.
	CharParser = parserLibrary CharParser.
	PredicateTokenParser = parserLibrary PredicateTokenParser.
	Transcript = platform Transcript.
	Dictionary = platform Dictionary.
	OrderedCollection = platform OrderedCollection.
	Number = platform Number.
	CollectingCommentParser = parserLibrary CollectingCommentParser.
	CombinatorialParser = parserLibrary CombinatorialParser.
|
)
(

class JSGrammar = ExecutableGrammar (
"Experiment for JS grammar based on the description from http://www.ecma-international.org/publications/standards/Ecma-262.htm"
|
      doubleQuote = (char: $").
      backslash = (char: $\).
	str = doubleQuote,((backslash, ( char: $" ))   | 
                                    (backslash, ( char: $/ ))  |
                                    (backslash, backslash)    |
                                    (backslash, ( char: $r ))   |
                                    (backslash, ( char: $n ))   |
                                    (backslash, ( char: $t ))   |
  	                              (charExceptFor: $")) star, doubleQuote.
	string = tokenFor: str.
	
	tilde = char: $~.
	exclamation = char: $!.
	starChar = char: $*.
	slash = char: $/.
	modulo = char: $%.
	pipe = char: $|.
      amp = char: $&.
      cir = char: $^.
      question = char: $?.
      colon = char: $:.
      semicolon = char: $;.
	
	negSign = (char: $-).
	plusSign = (char: $+).
	digit = (charBetween: $0 and: $9).
	dot = (char: $. ) .
	lt = char: $<.
	gt = char: $>.
	eq = char: $=.
	num = negSign opt, digit, digit star, dot opt,digit star, ((char: $e) | (char: $E)) opt, (plusSign | negSign) opt,digit star.
	number = tokenFor: num.

     tQuestion = tokenFor: question.
     tColon = tokenFor: colon.
     tplusSign = tokenFor: plusSign.
     tnegSign = tokenFor: negSign.
     tmodulo = tokenFor: modulo.
     tslash = tokenFor: slash.
     tstarChar = tokenFor: starChar.
     texclamation = tokenFor:exclamation.
     tdot = tokenFor:dot.
     tLt = tokenFor: lt.
     tGt = tokenFor: gt.
     tEq = tokenFor: eq.   
     tAmp = tokenFor: amp.
     tPipe = tokenFor: pipe.
     tCir = tokenFor: cir.
     tSlash = tokenFor: slash.
     tSemicolon = tokenFor: semicolon.

     tStarEq = tstarChar,eq.
     tModEq = tmodulo,eq.
     tSlashEq = tSlash,eq.
     tPlusEq = tplusSign,eq.
     tMinusEq = tnegSign,eq.
     tAmpAmp = tAmp,amp.
     tPipePipe = tPipe,pipe.
     tLtEq = tLt,eq.
     tGtEq = tGt,eq.
     tleftShift = tLt,lt.
     trightShift = tGt,gt.
     tsRightShift = tGt,gt,gt. 
     tEqEq = tEq,eq.
     tEqEqEq = tEq,eq,eq.
     tNotEq = texclamation,eq.
     tNotEqEq = texclamation,eq,eq.
     tleftShiftEq = tleftShift,eq.
     trightShiftEq = trightShift,eq.
     tsRightShiftEq = tsRightShift,eq.
     tAmpEq = tAmp,eq.
     tPipeEq = tPipe,eq.
     tCirEq = tCir,eq.

     lineTerminator = (char: (Character lf)) | (char: (Character cr)).

     regularExpressionLiteral = 
                     tslash, 
                     (  ((backslash, ( charExceptForCharIn: { (Character lf).  (Character cr). })) |
                      (charExceptForCharIn: { (Character lf).  (Character cr). $/.})) plus),
                      slash, (identifierStart star).

      leftparen = tokenFromChar: $(.
      rightparen =tokenFromChar: $).	
	
      leftbrace = tokenFromChar: ${.
      rightbrace =tokenFromChar: $}.
      comma = tokenFromChar: $,.
      propertyName = string | identifier | number.
      propertyNameAndValue = propertyName,tColon,value.
      obj =  leftbrace,  (propertyNameAndValue starSeparatedBy: comma),rightbrace.
      object =  obj.

      leftbracket = tokenFromChar: $[.
	rightbracket = tokenFromChar: $].
      arr = leftbracket, (value starSeparatedBy: comma), rightbracket.
      array = tokenFor: arr.

      comment = (slash,starChar,blockCommentBody,starChar,slash) | (slash,slash, lineCommentBody).


      ttrue = tokenFromSymbol: #true.
      tfalse = tokenFromSymbol: #false.
      null = tokenFromSymbol: #null.
      function = tokenFromSymbol: #function.
      tnew = tokenFromSymbol: #new.
      break = tokenFromSymbol: #break.
      case = tokenFromSymbol: #case.
      catch = tokenFromSymbol: #catch.
      continue = tokenFromSymbol: #continue.
      default = tokenFromSymbol: #default.
      delete = tokenFromSymbol: #delete.
      do = tokenFromSymbol: #do.
      else = tokenFromSymbol: #else.
      finally = tokenFromSymbol: #finally.
      for = tokenFromSymbol: #for.
      if = tokenFromSymbol: #if.
      in = tokenFromSymbol: #in.
      instanceof = tokenFromSymbol: #instanceof.
      return = tokenFromSymbol: #return.
      switch = tokenFromSymbol: #switch.
      this = tokenFromSymbol: #this.
      throw = tokenFromSymbol: #throw.
      try = tokenFromSymbol: #try.
      typeof  = tokenFromSymbol: #typeof.
      var = tokenFromSymbol: #var.
      void = tokenFromSymbol: #void.
      while = tokenFromSymbol: #while.
      with = tokenFromSymbol: #with.

      
 
      letter = (charBetween: $a and: $z) | (charBetween: $A and: $Z).
      identifierStart =  letter | (char: $$) | (char: $_).
      identifier = accept: (tokenFor: (identifierStart), (identifierStart | digit) star) ifNotIn: keywords .

      value =  assignmentExpression .      
  
      literal  = null | ttrue | tfalse | number | string |  regularExpressionLiteral.

      primaryexpression  = this |  literal | identifier | array | object | parenthesized.

      parenthesized = leftparen,expression,rightparen.

      functionexpression = function , identifier opt, 
                                       leftparen,formalParameterList , rightparen ,
                                       leftbrace,sourceElements,rightbrace.
      formalParameterList = identifier starSeparatedBy: comma. 

      memberexpression =   (simplememberexpression  ),
                                         (( leftbracket, expression, rightbracket) | ( tdot, identifier)) star.
     
     simplememberexpression = primaryexpression | 
                                               functionexpression  |                        
                                                simpleNewExpression.
      simpleNewExpression = tnew,memberexpression, arguments.

      
  
      callExpression =  (simplememberexpression  ),
                                 ( arguments |
                                  ( leftbracket, expression, rightbracket) | 
                                  ( tdot, identifier)  ) star.
      simpleCallExpression = memberexpression , arguments.
      arguments = leftparen ,
                          (assignmentExpression, (comma, assignmentExpression) star) opt, 
                          rightparen.

      newExpression = memberexpression | simpleNewMemberExpression.
      simpleNewMemberExpression = tnew, memberexpression.
 
      plusPlus = plusSign,plusSign.
      minusMinus = negSign,negSign.

      leftHandSideExpression = callExpression | newExpression  .
      postfixExpression = leftHandSideExpression , 
                                           ((plusPlus | minusMinus) star).


      unaryExpression =
          postfixExpression | complexUnaryExpression.

      complexUnaryExpression = 
           (typeof, unaryExpression) |
           (delete, unaryExpression) | 
           (void, unaryExpression) | 
           (plusPlus, unaryExpression) |
           (minusMinus, unaryExpression) |
           ((tokenFor: ( plusSign | negSign | tilde | exclamation )), unaryExpression).

      multiplicativeExpression = 
              unaryExpression, ((tstarChar | tslash | tmodulo), unaryExpression) star.     

      additiveExpression = 
              multiplicativeExpression, ((tplusSign | tnegSign), multiplicativeExpression) star. 

      shiftExpression =  
             additiveExpression,  ((tsRightShift | tleftShift |  trightShift), additiveExpression) star.
      
      relationalExpression =
            shiftExpression, ((  tLtEq | tGtEq | tLt | tGt | instanceof | in) , shiftExpression)  star.

      relationalExpressionNoIn =
            shiftExpression, ((  tLtEq | tGtEq | tLt | tGt | instanceof ) , shiftExpression)  star. 

      equalityExpression =
            relationalExpression, ((tEqEqEq | tEqEq | tNotEqEq | tNotEq ), relationalExpression) star.

      equalityExpressionNoIn =
            relationalExpressionNoIn, ((tEqEqEq | tEqEq | tNotEqEq | tNotEq ), relationalExpressionNoIn) star.

      bitwiseANDExpression =
           equalityExpression,(tAmp, equalityExpression) star.

      bitwiseANDExpressionNoIn =
           equalityExpressionNoIn,(tAmp, equalityExpressionNoIn) star.

      bitwiseXORExpression =
           bitwiseANDExpression,(tCir, bitwiseANDExpression) star.

      bitwiseXORExpressionNoIn =
           bitwiseANDExpressionNoIn,(tCir, bitwiseANDExpressionNoIn) star.

      bitwiseORExpression =
           bitwiseXORExpression,(tPipe, bitwiseXORExpression) star.

      bitwiseORExpressionNoIn =
           bitwiseXORExpressionNoIn,(tPipe, bitwiseXORExpressionNoIn) star.

      logicalAndExpression = 
           bitwiseORExpression, (tAmpAmp,bitwiseORExpression) star.

      logicalAndExpressionNoIn = 
           bitwiseORExpressionNoIn, (tAmpAmp,bitwiseORExpressionNoIn) star.

      logicalOrExpression = 
           logicalAndExpression, (tPipePipe,logicalAndExpression) star.

      logicalOrExpressionNoIn = 
           logicalAndExpressionNoIn, (tPipePipe,logicalAndExpressionNoIn) star.

      assignmentOperator = 
              tEq | tStarEq | tSlashEq | tModEq | tPlusEq | tMinusEq |
              tleftShiftEq | tsRightShiftEq | trightShiftEq | tAmpEq | tPipeEq |
              tCirEq.
 
      conditionalExpression =
            logicalOrExpression, (tQuestion, assignmentExpression,tColon,assignmentExpression) opt.

      assignmentExpression =    
           conditionalExpression, (assignmentOperator,conditionalExpression) star.

      conditionalExpressionNoIn =
            logicalOrExpressionNoIn, (tQuestion, assignmentExpressionNoIn,tColon,assignmentExpressionNoIn) opt.

      assignmentExpressionNoIn =    
           conditionalExpressionNoIn, (assignmentOperator,conditionalExpressionNoIn) star.

      expression = assignmentExpression, (comma , assignmentExpression) star.

      expressionNoIn = assignmentExpressionNoIn, (comma , assignmentExpressionNoIn) star.


      statement = block | variableStatement | emptyStatement | expressionStatement |
                          ifStatement | iterationStatement | withStatement | switchStatement |
                          labelledStatement | tryStatement | throwStatement | 
                          breakStatement | returnStatement.
  
      block = leftbrace, statementList , rightbrace.

      statementList = statement star.
      variableStatement = var, variableDeclarationList, tSemicolon.

      variableDeclarationList = (variableDeclaration plusSeparatedBy: comma). 
      variableDeclaration = identifier, (tEq,assignmentExpression) opt.

      variableDeclarationListNoIn = (variableDeclarationNoIn plusSeparatedBy: comma). 
      variableDeclarationNoIn = identifier, (tEq,assignmentExpressionNoIn) opt.
       
      emptyStatement = tSemicolon.

      expressionStatement = (((function | leftbrace) not) & expression), tSemicolon.

      ifStatement = if, leftparen,expression,rightparen,statement,(else,statement) opt.

      iterationStatement = doStatement | forStatement | forStatementNoVar |  
                                        whileStatement | forInStatement | forInStatementNoVar.

      doStatement = do, statement, while, leftparen,expression,rightparen,tSemicolon.

       forStatement = for, leftparen, 
                                       var, variableDeclarationListNoIn ,
                                       tSemicolon,
                                       (expression opt),
                                       tSemicolon,
                                       (expression opt),
                                       rightparen, statement.

      forStatementNoVar = for, leftparen, 
                                       (expression opt),
                                       tSemicolon,
                                       (expression opt),
                                       tSemicolon,
                                       (expression opt),
                                       rightparen, statement.


       forInStatement = for, leftparen, 
                                       var, variableDeclarationListNoIn ,
                                       in,
                                       expression ,
                                       rightparen, statement.

      forInStatementNoVar = for, leftparen, 
                                       leftHandSideExpression ,
                                       in,
                                       expression ,
                                       rightparen, statement.
      whileStatement = while,leftparen,expression,rightparen,statement.

      continueStatement = continue, (identifier opt), tSemicolon.

      breakStatement = break, (identifier opt), tSemicolon.

      returnStatement = return, (expression opt), tSemicolon.

      withStatement = with, leftparen, expression ,rightparen, statement.
  
       switchStatement = switch ,leftparen,expression,rightparen, clauseBlock.

       clauseBlock = leftbrace,(clause star),(defaultClause opt),rightbrace.

       clause = case, expression, tColon,statementList.
         
        defaultClause = default,tColon, statementList.

        labelledStatement = identifier,tColon,statement.
        
        throwStatement = throw,expression,tSemicolon.
 
        tryStatement = try, block, (catchBlock opt), (finallyBlock opt).

         catchBlock = catch, leftparen, identifier,rightparen, block.

         finallyBlock = finally, block.

         functionDeclaration = function,identifier,
                                           leftparen,formalParameterList,rightparen,
                                           leftbrace,sourceElements,rightbrace.

 

         sourceElements = (statement | functionDeclaration ) star.

         program = sourceElements.
        
|
)
('as yet unclassified'
accept: parser ifNotIn: invalidWords <Array[String]> = (
	^ParserWithExceptions accept: parser  exceptions: invalidWords.
)

blockCommentBody = (
	^CollectingCommentParser new
	    termBlock: 
	          [:input | 
		       |c| 
		       c: input peek.
		       c isNil 
		          ifTrue: [false]
		          ifFalse: [ 
 			          (c = $*)
			             ifTrue: [  | p |				           
                                    p:: input position.
                                    input next.                                    
                                    (input peek = $/) 
                                           ifTrue: [input position: p. true]
                                           ifFalse: [ false] ]  
                                ifFalse: [false]  ] ]
		         
)

charExceptFor: aChar = (
	^CharExceptForParser new for: aChar
)

charExceptForCharIn: chars <Array> = (
	^CharExceptForParser new forCharIn: chars
)

keywords = (^{ 'break' . 'else' . 'new' . 'case' . 'finally' . 'return' . 'catch' . 'for' . 
'switch' . 'continue' . 'function' . 'this' . 'default' . 'if' . 'throw' .  
'delete' . 'in' . 'try' . 'do' . 'instanceof' . 'typeof' . 'var' . 'void' . 
'while' . 'with'. })

lineCommentBody = (
	^CollectingCommentParser new
	    termBlock: 
	          [:input | 
		       |c| 		        
		       c: input peek.
		       ((c = nil) or: [ (c asciiValue) = 13 ]) ]
)

)

class CharExceptForParser = PredicateTokenParser (
"Parses any character expect for the specified."
|

|
)
('as yet unclassified'
for: aChar = (
	^self accept: [:c | c ~= aChar] errorMsg: ''
)

forCharIn: chars <Array> = (
	^self accept: [:c |  (chars includes: c) not] errorMsg: ''
)

)

class JSObject withContent: dContent =  (
"Instances of this class represent JS objects."
|
	content = dContent.
|
)
('as yet unclassified'
doesNotUnderstand: message = (
      | fieldName |
      fieldName:: message selector string.
      (fieldName beginsWith: 'json_')  
             ifTrue: [fieldName:: fieldName allButFirst: 5].
	^content  at: fieldName ifAbsent: [nil].
)

)

class ParserWithExceptions accept: acceptParser exceptions: exceptionArray = CombinatorialParser (
"Parses using one parser and fails if the second parser succeeds."
|
	acceptParser = acceptParser.
	exceptions
 
|
	initExceptions: exceptionArray.
)
('as yet unclassified'
initExceptions: exceptionArray = (
	exceptions:: Dictionary new.
	exceptionArray do: [:e | exceptions at: e put: true ].

)

parse: input inContext: ctxt  ifError: blk = (
	|initialPosition result executed tstr|
	initialPosition:: input position.
	executed: true.
	
	result::
	     acceptParser parse: input 
	                     inContext: ctxt 
	                     ifError: [:m :p | blk value: m value: p. 
		                                      executed: false].
	executed ifTrue: [
            tstr::  ((result token at: 1) asString),
                       (String withAll: (result token at:2)).
		(exceptions  includesKey: tstr)
		      ifTrue: [ blk value: 'Keyword when expecting identifier'
			                   value: initialPosition]		
		      ifFalse: [ ^result ].
		                       ]
)

)

class TestingAstNode name: theName contents: theContent = (
"Ast node used for parser tests"
|
	public name = theName.
	public contents = theContent.
|
)
('as yet unclassified'
private compare: a with: b = (
      |t i|
	(a respondsTo:  #sameAs:)
			ifTrue: [t:: a sameAs: b]
			ifFalse: [
				 (a class name = #Array)
				   ifTrue: [
					  i:: 0.
					  t:: a inject: true into: [:total :current | 
						                          i:: i+1.
						                          total and: [compare: current 
							                                          with: (b at: i) ] ]]
				   ifFalse: [ t:: a = b]] .
     t ifFalse: [break].
     ^t.
)

sameAs: other = (
     |t i|
      
     ^ (  (compare: other name with: name)
             and: [compare: contents size with: other contents size]  ) 
              and: [

	              t: true.
	              i:1.
	              other contents do: [ :e |  
		                   t ifTrue: 
		                        [ t:: compare: e with: (contents at: i).].
		                   i:i+1.].
	              t].
	
)

)

class JSGrammarWithAST = JSGrammar(
"Parses a JS File and generates and Ast"
|
	
|
)
('as yet unclassified'
additiveExpression = (
	^super additiveExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#additive
		                                    first: first rest: rest ].
)

arguments = (
		^super arguments wrapper: [:lp :args :rp | flattenArguments: args  ].
)

array = (
	^super array wrapper: [:a | (a token at: 2)  ].
)

assignmentExpression = (
	^super assignmentExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#assign
		                                    first: first rest: rest ].
)

assignmentExpressionNoIn = (
	^super assignmentExpressionNoIn 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#assign
		                                    first: first rest: rest ].
)

binaryExpressionIdentifier: id = (     
	^(id respondsTo: #token) 
	    ifTrue: [id token]
	    ifFalse: [		   
		 String withAll:
		      (id inject: (OrderedCollection new) into: [:a :b |
			       a addLast:( (b respondsTo: #token) ifTrue: [b token]
			                             ifFalse: [b]
			                            ) .
			       a
			 ]).
		
		]
)

bitwiseANDExpression = (
	^super bitwiseANDExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitAnd
		                                    first: first rest: rest ].
)

bitwiseANDExpressionNoIn = (
	^super bitwiseANDExpressionNoIn 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitAnd
		                                    first: first rest: rest ].
)

bitwiseORExpression = (
	^super bitwiseORExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitOr
		                                    first: first rest: rest ].
)

bitwiseORExpressionNoIn = (
	^super bitwiseORExpressionNoIn
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitOr
		                                    first: first rest: rest ].
)

bitwiseXORExpression = (
	^super bitwiseXORExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitXor
		                                    first: first rest: rest ].
)

bitwiseXORExpressionNoIn = (
	^super bitwiseXORExpressionNoIn
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitXor
		                                    first: first rest: rest ].
)

block = (
	^super block 
	                  wrapper: [:lb :statements :rb |   
		                                TestingAstNode name: #block
		                                    contents: (statements asArray). ].
)

breakStatement = (
	^super breakStatement 
	     wrapper: [:b :id :sc |
		       TestingAstNode name: #break
		           contents: { id }
		 ]
)

callExpression = (
		^super callExpression 
	                 wrapper: [:id :col | 
		                       flattenCallExpression: col from: id.
		                                           ].
)

catchBlock = (
	^super catchBlock 
	                  wrapper: [:catch :lp :var :rp :block |   
		                               TestingAstNode name: #catch
		                                  contents: {  var. block. }.]
)

clause = (
	^super clause 
	                  wrapper: [:case :expr :sc :statements |   
		                               TestingAstNode name: #case 
		                                  contents: {expr. (statements asArray) } ]
)

clauseBlock = (
	^super clauseBlock 
	                  wrapper: [:lb :clauses :default :rb |   
		                               default ifNotNil: [clauses addLast: default].
		                               clauses]
)

complexUnaryExpression = (
	^super complexUnaryExpression 
	             wrapper: [:op :exp | 
		                  TestingAstNode 
		                           name: #unary 
		                           contents: { (op respondsTo: #token) 
		                                                     ifTrue: [op token]
		                                                     ifFalse: [op] . 
		                                            exp. }  ].
)

conditionalExpression = (
	^super conditionalExpression 
	                 wrapper: [:condition :col |   
		                             (col = nil) 
		                                 ifTrue: [condition]
		                                 ifFalse: [
                                                  TestingAstNode name: #conditional
		                                               contents: { condition. 
		                                                                 col at: 2. 
		                                                                 col at: 4. }]].
)

conditionalExpressionNoIn = (
	^super conditionalExpressionNoIn 
	                 wrapper: [:condition :col |   
		                             (col = nil) 
		                                 ifTrue: [condition]
		                                 ifFalse: [
                                                  TestingAstNode name: #conditional
		                                               contents: { condition. 
		                                                                 col at: 2. 
		                                                                 col at: 4. }]].
)

continueStatement = (
	^super continueStatement 
	     wrapper: [:b :id :sc |
		       TestingAstNode name: #continue
		           contents: { id }
		 ]
)

createNodeForBinaryExpression: type first: first rest: rest = (
	^rest inject: first into: [ 
			                         :current :next |
			                              TestingAstNode
			                                  name: type
			                                  contents: {  binaryExpressionIdentifier: (next at: 1)  " (next at: 1) token".
			                                                    current.
			                                                    next at: 2. }]
)

defaultClause = (
	^super defaultClause 
	                  wrapper: [:default :sc :statements |   
		                               TestingAstNode name: #defaultCase contents: (statements asArray)]
)

doStatement = (
	^super doStatement 
	                  wrapper: [:do :statement :while :lp :condition :rp :sc |   
		                               TestingAstNode name: #do
		                                  contents: { statement. condition }.]
)

equalityExpression = (
	^super equalityExpression 
	                 wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#equality
		                                    first: first rest: rest ].
)

equalityExpressionNoIn = (
	^super equalityExpressionNoIn
	                 wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#equality
		                                    first: first rest: rest ].
)

expression = (
	^super expression 
	                wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#comma
		                                first: first rest: rest ].
)

expressionNoIn = (
	^super expressionNoIn 
	                wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#comma
		                                first: first rest: rest ].
)

expressionStatement = (
	^super expressionStatement 
	                  wrapper: [:n :expression :sc |   
		                                TestingAstNode name: #expressionStatement
		                                    contents: { expression }. ].
)

finallyBlock = (
	^super finallyBlock 
	                  wrapper: [:finally :block |   
		                               TestingAstNode name: #finally
		                                  contents: {   block. }.]
)

flattenArguments: args = (
	|col| 
      
	^((args isNil not) and: [args size > 0 ])
           ifTrue: [
               col: OrderedCollection new.
	         col addLast: (args at: 1).
	         ((args at: 2) size > 0) ifTrue: [
		       (args at: 2) do: [:i | col addLast: (i at: 2) ].
		   ].
	         col asArray.
	     ]
           ifFalse: [ {} ].
)

flattenCallExpression:col from: initial = (
	|tmp|
	tmp: initial.
	col do: [ :i |
		   ((i class name) = #Array) ifTrue:[ tmp:: TestingAstNode  
			                                        name: #call 
			                                        contents: {tmp. i.}]
                 ifFalse: [
                          (((i at: 1) token) = $.) ifTrue:[ tmp:: TestingAstNode  
			                                        name: #memberAccess 
			                                        contents: {tmp. i at: 2.}].
                          (((i at: 1) token) = $[) ifTrue:[ tmp:: TestingAstNode  
			                                        name: #arrayAccess 
			                                        contents: {tmp. i at: 2.}].
		   ].
		 ].
	^tmp.

)

flattenCharCollectionToString: collection = (
    | newCollection |
    newCollection:: OrderedCollection new: (collection size).
    ^(String withAll: (flatteningCollectedString: collection to: newCollection))
)

flattenMemberExpression: col from: initial = (	
	|tmp|
	tmp: initial.
	col do: [ :i |
		   (((i at: 1) token) = $.) ifTrue:[ tmp:: TestingAstNode  
			                                        name: #memberAccess 
			                                        contents: {tmp. i at: 2.}].
	 	   (((i at: 1) token) = $[) ifTrue:[ tmp:: TestingAstNode  
			                                        name: #arrayAccess 
			                                        contents: {tmp. i at: 2.}].
		 ].
	^tmp.
)

flatteningCollectedString: collection to: newCollection = (
    collection do:
          [:value | 
	      #OrderedCollection = (value class name)
	          ifTrue: [ flatteningCollectedString: value to: newCollection ]
	          ifFalse: [value ~= nil ifTrue: [newCollection addLast: value]]].
    ^newCollection
)

forInStatement = (
	^super forInStatement 
	                  wrapper: [:for :lp :var :initial :in :col :rp :statement |   
		                               TestingAstNode name: #forIn
		                                  contents: {
		                                           TestingAstNode name: #vardeclarations contents: (initial  asArray).
		                                            col. statement. }.]
)

forInStatementNoVar = (
	^super forInStatementNoVar 
	                  wrapper: [:for :lp  :initial :in :col :rp :statement|   
		                               TestingAstNode name: #forIn
		                                  contents: {
 		                                            initial.
		                                            col. statement. }.]
)

forStatement = (
	^super forStatement 
	                  wrapper: [:for :lp :var :initial :sc1 :condition :sc2 :inc :rp :statement |   
		                               TestingAstNode name: #for
		                                  contents: {
		                                           TestingAstNode name: #vardeclarations contents: (initial  asArray).
		                                            condition. inc. statement. }.]
)

forStatementNoVar = (
	^super forStatementNoVar 
	                  wrapper: [:for :lp  :initial :sc1 :condition :sc2 :inc :rp :statement |   
		                               TestingAstNode name: #for
		                                  contents: {
 		                                            initial.
		                                            condition. inc. statement. }.]
)

functionexpression = (
	^super functionexpression wrapper:
	    [:fun :fname :lp :params :rp :lb :elements :rb |  TestingAstNode name: #function
		                                contents: {fname. (params asArray). (elements asArray).}].
)

getEscapedValue: collection <OrderedCollection> = (
     | result | 
     ((collection at: 2) = $n )
         ifTrue: [result:: string lf ]
         ifFalse:[result:: (collection at: 2) ].
     ^result
)

identifier  = (
	^super identifier wrapper: [ :k |  (flattenCharCollectionToString: (k token  ))].
)

ifStatement = (
	^super ifStatement 
	                  wrapper: [:if :lp :condition :rp :thenStatement :elseCol |   
		                                (elseCol = nil)
		                                         ifTrue: [ TestingAstNode name: #if 
			                                                     contents: { condition. thenStatement.} ]
		                                         ifFalse: [ TestingAstNode name: #if 
			                                                     contents: { condition. 
			                                                                       thenStatement.
			                                                                       elseCol at: 2.} ]
		                         ].
)

labelledStatement = (
	^super labelledStatement 
	                  wrapper: [:label :sc :statement |   
		                                TestingAstNode name: #label contents: {label. statement.}. ].
)

logicalAndExpression = (
	^super logicalAndExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#and
		                                    first: first rest: rest ].
)

logicalAndExpressionNoIn = (
	^super logicalAndExpressionNoIn 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#and
		                                    first: first rest: rest ].
)

logicalOrExpression = (
	^super logicalOrExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#or
		                                    first: first rest: rest ].
)

logicalOrExpressionNoIn = (
	^super logicalOrExpressionNoIn 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#or
		                                    first: first rest: rest ].
)

memberexpression = (
	^super memberexpression 
	                  wrapper: [:id :col | 
		                                (col size = 0) 
		                                ifTrue: [ id]
                                            ifFalse: [ flattenMemberExpression:col from:id].
		                                           ].
)

messageSelector = (
	^ super variableStatement 
)

minusMinus = (
	^super minusMinus wrapper: [:m1 :m2 | '--' ].
)

multiplicativeExpression = (
	^super multiplicativeExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#multiplicative
		                                    first: first rest: rest ].
)

null = (
	^ super null wrapper: [:o | nil].
)

number = (
	^super number wrapper: [:o | Number readFrom: (flattenCharCollectionToString: (o token)) ].
)

object  = (
	^super object wrapper: 
	      [:lb :defs :rb | 
		     TestingAstNode name: #object
		            contents: (defs asArray)].
)

parenthesized = (
	^super parenthesized wrapper: 
	                  [:lp :expression :rp |  
		                  TestingAstNode name: #paren contents: { expression }.
		              ].
)

parse: input  = (
	^super value parse: input.
)

plusPlus = (
	^super plusPlus wrapper: [:p1 :p2 | '++' ].
)

postfixExpression = (
	^super postfixExpression 
	               wrapper: [:obj :post | 		                            
		                          post inject: obj into: [:o :i |
			                            TestingAstNode name: #postfix
			                                        contents: {
			                                             i at: 1.
			                                             o.
			                                        }.
			                    ] ]. 
)

program = (
	^super program wrapper: [:elements | elements asArray  ].
)

propertyNameAndValue  = (
	^super propertyNameAndValue wrapper: 
	      [:name :c :value | 
		     TestingAstNode name: #objectEntry
		            contents: {name. value.}].
)

regularExpressionLiteral = (
	^super regularExpressionLiteral 
	                  wrapper: [:sl1 :searchPart :sl2 :modifiers |   
		                               TestingAstNode name: #regexLiteral
		                                  contents: {
		                                       flattenCollectedString: searchPart.
		                                       modifiers asArray.
		                                   }.]
)

relationalExpression = (
	^super relationalExpression 
	                 wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#relational
		                                    first: first rest: rest ].
)

relationalExpressionNoIn = (
	^super relationalExpressionNoIn 
	                 wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#relational
		                                    first: first rest: rest ].
)

returnStatement = (
	^super returnStatement 
	     wrapper: [:r :expression :sc |
		       TestingAstNode name: #return
		           contents: ((expression = nil) 
		                                ifTrue: [{  }]
		                                ifFalse: [{ expression  }]
		                            )
		 ]
)

shiftExpression = (
	^super shiftExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#shift
		                                    first: first rest: rest ].
)

simpleNewExpression = (
	^super simpleNewExpression 
	              wrapper: [:nt :mem :args | 
		                            TestingAstNode  
		                                      name: #new 
		                                      contents:{ mem. args.  } ].
)

simpleNewMemberExpression = (
	^super simpleNewMemberExpression  wrapper: [:a :b | TestingAstNode name: #new contents: { b. }].
"	           wrapper: [:a :b | ((a class name) = #OrderedCollection) 
		                             ifTrue: [TestingAstNode  
			                                        name: #new 
			                                        contents: {a at: 1. a at: 2.}] 
 	                                   ifFalse: [ a ]. ]"
)

string  = (
	^super string wrapper: 
	       [:t | flattenCollectedString: (t token at: 2)].
)

switchStatement = (
	^super switchStatement 
	                  wrapper: [:switch :lp :expression :rp :clauses |   
		                               clauses addFirst: expression.
		                               TestingAstNode name: #switch
		                                  contents: (clauses asArray) .]
)

tAmpAmp = (
	^super tAmpAmp wrapper: [:f :s | '&&'].
)

tPipePipe = (
	^super tPipePipe wrapper: [:f :s | '||'].
)

this = (
	^super this wrapper: [:o | #this].
)

throwStatement = (
	^super throwStatement 
	                  wrapper: [:throw :exp :sc |   
		                                TestingAstNode name: #throw contents: {exp}. ].
)

tryStatement = (
	^super tryStatement 
	                  wrapper: [:try :block :catch :finally |   
		                               TestingAstNode name: #try
		                                  contents: {  block.  catch. finally. }.]
)

variableDeclaration = (
		^super variableDeclaration 
	                  wrapper: [:varName  :optionalInitialValue |   
		                                TestingAstNode name: #vardeclaration
		                                         contents: ((optionalInitialValue = nil) 
		                                                                 ifTrue: [{ varName.  }]
		                                                                 ifFalse: [{ varName. (optionalInitialValue at: 2)}]
		) ]
)

variableDeclarationNoIn = (
		^super variableDeclarationNoIn 
	                  wrapper: [:varName  :optionalInitialValue |   
		                                TestingAstNode name: #vardeclaration
		                                         contents: ((optionalInitialValue = nil) 
		                                                                 ifTrue: [{ varName.  }]
		                                                                 ifFalse: [{ varName. (optionalInitialValue at: 2)}]
		) ]
)

variableStatement = (
		^super variableStatement 
	                  wrapper: [:v :declarationList :sc |   
		                                TestingAstNode name: #vardeclarations 
		                                         contents: ( declarationList asArray  ) ]
)

whileStatement = (
	^super whileStatement 
	                  wrapper: [:while :lp  :condition :rp :statement |   
		                               TestingAstNode name: #while
		                                  contents: {
 		                                            
		                                            condition.  statement. }.]
)

'primitive'
tfalse = (
	^super tfalse   wrapper: [:f | false].
)

ttrue = (
	^super ttrue   wrapper: [:t | true].
)

'complex'
flattenCollectedString: collection = (
    | newCollection |
    newCollection:: OrderedCollection new: (collection size).
    collection do:
          [:value | 
	      #OrderedCollection = (value class name)
	          ifTrue: [ newCollection addLast: (getEscapedValue: value) ]
	          ifFalse: [newCollection addLast: value]].
    ^(String withAll: newCollection)
)

))