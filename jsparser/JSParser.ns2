Newsqueak2
'LangexplrExperiments'

class JSParser withParserLib: parserLibrary usingLib: platform =  (
"Experiment for JS parser based on the description from http://www.json.org/fatfree.html "
|
	ExecutableGrammar = parserLibrary ExecutableGrammar.
	CharParser = parserLibrary CharParser.
	PredicateTokenParser = parserLibrary PredicateTokenParser.
	Dictionary = platform Dictionary.
	OrderedCollection = platform OrderedCollection.
	Number = platform Number.
|
)
(

class JSGrammar = ExecutableGrammar (
"Experiment for JS grammar based on the description from http://www.ecma-international.org/publications/standards/Ecma-262.htm"
|
      doubleQuote = (char: $").
      backslash = (char: $\).
	str = doubleQuote,((backslash, ( char: $" ))   | 
                                    (backslash, ( char: $/ ))  |
                                    (backslash, backslash)    |
                                    (backslash, ( char: $r ))   |
                                    (backslash, ( char: $n ))   |
                                    (backslash, ( char: $t ))   |
  	                              (charExceptFor: $")) star, doubleQuote.
	string = tokenFor: str.
	
	tilde = char: $~.
	exclamation = char: $!.
	starChar = char: $*.
	slash = char: $/.
	modulo = char: $%.
	pipe = char: $|.
      amp = char: $&.
      cir = char: $^.
      question = char: $?.
      colon = char: $:.
      semicolon = char: $;.
	
	negSign = (char: $-).
	plusSign = (char: $+).
	digit = (charBetween: $0 and: $9).
	dot = (char: $. ) .
	lt = char: $<.
	gt = char: $>.
	eq = char: $=.
	num = negSign opt, digit, digit star, dot opt,digit star, ((char: $e) | (char: $E)) opt, (plusSign | negSign) opt,digit star.
	number = tokenFor: num.

     tQuestion = tokenFor: question.
     tColon = tokenFor: colon.
     tplusSign = tokenFor: plusSign.
     tnegSign = tokenFor: negSign.
     tmodulo = tokenFor: modulo.
     tslash = tokenFor: slash.
     tstarChar = tokenFor: starChar.
     texclamation = tokenFor:exclamation.
     tdot = tokenFor:dot.
     tLt = tokenFor: lt.
     tGt = tokenFor: gt.
     tEq = tokenFor: eq.   
     tAmp = tokenFor: amp.
     tPipe = tokenFor: pipe.
     tCir = tokenFor: cir.
     tSlash = tokenFor: slash.
     tSemicolon = tokenFor: semicolon.

     tStarEq = tstarChar,eq.
     tModEq = tmodulo,eq.
     tSlashEq = tSlash,eq.
     tPlusEq = tplusSign,eq.
     tMinusEq = tnegSign,eq.
     tAmpAmp = tAmp,amp.
     tPipePipe = tPipe,pipe.
     tLtEq = tLt,eq.
     tGtEq = tGt,eq.
     tleftShift = tLt,lt.
     trightShift = tGt,gt.
     tsRightShift = tGt,gt,gt. 
     tEqEq = tEq,eq.
     tEqEqEq = tEq,eq,eq.
     tNotEq = texclamation,eq.
     tNotEqEq = texclamation,eq,eq.
     tleftShiftEq = tleftShift,eq.
     trightShiftEq = trightShift,eq.
     tsRightShiftEq = tsRightShift,eq.
     tAmpEq = tAmp,eq.
     tPipeEq = tPipe,eq.
     tCirEq = tCir,eq.
     

      leftparen = tokenFromChar: $(.
      rightparen =tokenFromChar: $).	
	
      leftbrace = tokenFromChar: ${.
      rightbrace =tokenFromChar: $}.
      comma = tokenFromChar: $,.
      definition = string,tColon,value.
      obj =  leftbrace,  (definition starSeparatedBy: comma),rightbrace.
      object = tokenFor: obj.

      leftbracket = tokenFromChar: $[.
	rightbracket = tokenFromChar: $].
      arr = leftbracket, (value starSeparatedBy: comma), rightbracket.
      array = tokenFor: arr.

      ttrue = tokenFromSymbol: #true.
      tfalse = tokenFromSymbol: #false.
      null = tokenFromSymbol: #null.
      function = tokenFromSymbol: #function.
      tnew = tokenFromSymbol: #new.
      break = tokenFromSymbol: #break.
      case = tokenFromSymbol: #case.
      catch = tokenFromSymbol: #catch.
      continue = tokenFromSymbol: #continue.
      default = tokenFromSymbol: #default.
      delete = tokenFromSymbol: #delete.
      do = tokenFromSymbol: #do.
      else = tokenFromSymbol: #else.
      finally = tokenFromSymbol: #finally.
      for = tokenFromSymbol: #for.
      if = tokenFromSymbol: #if.
      in = tokenFromSymbol: #in.
      instanceof = tokenFromSymbol: #instanceof.
      return = tokenFromSymbol: #return.
      switch = tokenFromSymbol: #switch.
      this = tokenFromSymbol: #this.
      throw = tokenFromSymbol: #throw.
      try = tokenFromSymbol: #try.
      typeof  = tokenFromSymbol: #typeof.
      var = tokenFromSymbol: #var.
      void = tokenFromSymbol: #void.
      while = tokenFromSymbol: #while.
      with = tokenFromSymbol: #with.

      keyword = break | else | tnew | case | finally | return | catch | for | 
                       switch | continue | function | this | default | if | throw | 
                       delete | in | try | do | instanceof | typeof | var | void | 
                       while | with. 
 
      letter = (charBetween: $a and: $z) | (charBetween: $A and: $Z).
      identifierStart =  letter | (char: $$) | (char: $_).
      identifier =  (keyword not) &(tokenFor: (identifierStart), (identifierStart | digit) star) .

      value =  string | number | object | array | ttrue | tfalse | null | identifier .      
  
      literal  = null | ttrue | tfalse | number | string.

      primaryexpression  = this |  literal | identifier | array | object.

      functionexpression = function , identifier opt, 
                                       leftparen,formalparamlist, rightparen ,
                                       leftbrace,rightbrace.
      formalparamlist = identifier , (comma , identifier) star. 

      memberexpression =   (simplememberexpression  ),
                                         (( leftbracket, expression, rightbracket) | ( tdot, identifier)) star.
     
     simplememberexpression = primaryexpression | 
                                               functionexpression  |                        
                                                simpleNewExpression.
      simpleNewExpression = tnew,memberexpression, arguments.

      
  
      callExpression =  (simplememberexpression  ),
                                 ( arguments |
                                  ( leftbracket, expression, rightbracket) | 
                                  ( tdot, identifier)  ) star.
      simpleCallExpression = memberexpression , arguments.
      arguments = leftparen ,
                          (assignmentExpression, (comma, assignmentExpression) star) opt, 
                          rightparen.

      newExpression = memberexpression | simpleNewMemberExpression.
      simpleNewMemberExpression = tnew, memberexpression.
 
      plusPlus = plusSign,plusSign.
      minusMinus = negSign,negSign.

      leftHandSideExpression = callExpression | newExpression  .
      postfixExpression = leftHandSideExpression , 
                                           ((plusPlus | minusMinus) star).


      unaryExpression =
          postfixExpression | complexUnaryExpression.

      complexUnaryExpression = 
           (typeof, unaryExpression) |
           (delete, unaryExpression) | 
           (void, unaryExpression) | 
           (plusPlus, unaryExpression) |
           (minusMinus, unaryExpression) |
           (( plusSign | negSign | tilde | exclamation ), unaryExpression).

      multiplicativeExpression = 
              unaryExpression, ((tstarChar | tslash | tmodulo), unaryExpression) star.     

      additiveExpression = 
              multiplicativeExpression, ((tplusSign | tnegSign), multiplicativeExpression) star. 

      shiftExpression =  
             additiveExpression,  ((tsRightShift | tleftShift |  trightShift), additiveExpression) star.
      
      relationalExpression =
            shiftExpression, ((  tLtEq | tGtEq | tLt | tGt | instanceof | in) , shiftExpression)  star.

      relationalExpressionNoIn =
            shiftExpression, ((  tLtEq | tGtEq | tLt | tGt | instanceof ) , shiftExpression)  star. 

      equalityExpression =
            relationalExpression, ((tEqEqEq | tEqEq | tNotEqEq | tNotEq ), relationalExpression) star.

      equalityExpressionNoIn =
            relationalExpressionNoIn, ((tEqEqEq | tEqEq | tNotEqEq | tNotEq ), relationalExpressionNoIn) star.

      bitwiseANDExpression =
           equalityExpression,(tAmp, equalityExpression) star.

      bitwiseANDExpressionNoIn =
           equalityExpressionNoIn,(tAmp, equalityExpressionNoIn) star.

      bitwiseXORExpression =
           bitwiseANDExpression,(tCir, bitwiseANDExpression) star.

      bitwiseXORExpressionNoIn =
           bitwiseANDExpressionNoIn,(tCir, bitwiseANDExpressionNoIn) star.

      bitwiseORExpression =
           bitwiseXORExpression,(tPipe, bitwiseXORExpression) star.

      bitwiseORExpressionNoIn =
           bitwiseXORExpressionNoIn,(tPipe, bitwiseXORExpressionNoIn) star.

      logicalAndExpression = 
           bitwiseORExpression, (tAmpAmp,bitwiseORExpression) star.

      logicalAndExpressionNoIn = 
           bitwiseORExpressionNoIn, (tAmpAmp,bitwiseORExpressionNoIn) star.

      logicalOrExpression = 
           logicalAndExpression, (tPipePipe,logicalAndExpression) star.

      logicalOrExpressionNoIn = 
           logicalAndExpressionNoIn, (tPipePipe,logicalAndExpressionNoIn) star.

      assignmentOperator = 
              tEq | tStarEq | tSlashEq | tModEq | tPlusEq | tMinusEq |
              tleftShiftEq | tsRightShiftEq | trightShiftEq | tAmpEq | tPipeEq |
              tCirEq.
 
      conditionalExpression =
            logicalOrExpression, (tQuestion, assignmentExpression,tColon,assignmentExpression) opt.

      assignmentExpression =    
           conditionalExpression, (assignmentOperator,conditionalExpression) star.

      conditionalExpressionNoIn =
            logicalOrExpressionNoIn, (tQuestion, assignmentExpressionNoIn,tColon,assignmentExpressionNoIn) opt.

      assignmentExpressionNoIn =    
           conditionalExpressionNoIn, (assignmentOperator,conditionalExpressionNoIn) star.

      expression = assignmentExpression, (comma , assignmentExpression) star.

      expressionNoIn = assignmentExpressionNoIn, (comma , assignmentExpressionNoIn) star.


      statement = block | variableStatement | emptyStatement | expressionStatement |
                          ifStatement | iterationStatement.
  
      block = leftbrace, statementList , rightbrace.

      statementList = statement star.
      variableStatement = var, variableDeclarationList, tSemicolon.

      variableDeclarationList = (variableDeclaration plusSeparatedBy: comma). 
      variableDeclaration = identifier, (tEq,assignmentExpression) opt.

      variableDeclarationListNoIn = (variableDeclarationNoIn plusSeparatedBy: comma). 
      variableDeclarationNoIn = identifier, (tEq,assignmentExpressionNoIn) opt.
       
      emptyStatement = tSemicolon.

      expressionStatement = (((function | leftbrace) not) & expression), tSemicolon.

      ifStatement = if, leftparen,expression,rightparen,statement,(else,statement) opt.

      iterationStatement = doStatement | forStatement | forStatementNoVar |  
                                        whileStatement | forInStatement | forInStatementNoVar.

      doStatement = do, statement, while, leftparen,expression,rightparen,tSemicolon.

       forStatement = for, leftparen, 
                                       var, variableDeclarationListNoIn ,
                                       tSemicolon,
                                       (expression opt),
                                       tSemicolon,
                                       (expression opt),
                                       rightparen, statement.

      forStatementNoVar = for, leftparen, 
                                       (expression opt),
                                       tSemicolon,
                                       (expression opt),
                                       tSemicolon,
                                       (expression opt),
                                       rightparen, statement.


       forInStatement = for, leftparen, 
                                       var, variableDeclarationListNoIn ,
                                       in,
                                       expression ,
                                       rightparen, statement.

      forInStatementNoVar = for, leftparen, 
                                       leftHandSideExpression ,
                                       in,
                                       expression ,
                                       rightparen, statement.
      whileStatement = while,leftparen,expression,rightparen,statement.
|
)
('as yet unclassified'
charExceptFor: aChar = (
	^CharExceptForParser new for: aChar
)

)

class CharExceptForParser = PredicateTokenParser (
"Parses any character expect for the specified."
|

|
)
('as yet unclassified'
for: aChar = (
	^self accept: [:c | c ~= aChar] errorMsg: ''
)

)

class TestingAstNode name: theName contents: theContent = (
"Ast node used for parser tests"
|
	public name = theName.
	public contents = theContent.
|
)
('as yet unclassified'
private compare: a with: b = (
      |t|
	(a respondsTo:  #sameAs:)
			ifTrue: [t:: a sameAs: b]
			ifFalse: [t:: a = b] .
     t ifFalse: [break].
     ^t.
)

sameAs: other = (
     |t i|
      
     ^ (  (compare: other name with: name)
             and: [compare: contents size with: other contents size]  ) 
              and: [

	              t: true.
	              i:1.
	              other contents do: [ :e |  
		                   t ifTrue: 
		                        [ t:: compare: e with: (contents at: i).].
		                   i:i+1.].
	              t].
	
)

)

class JSObject withContent: dContent =  (
"Instances of this class represent JS objects."
|
	content = dContent.
|
)
('as yet unclassified'
doesNotUnderstand: message = (
      | fieldName |
      fieldName:: message selector string.
      (fieldName beginsWith: 'json_')  
             ifTrue: [fieldName:: fieldName allButFirst: 5].
	^content  at: fieldName ifAbsent: [nil].
)

)

class JSGrammarWithAST = JSGrammar(
"Parses a JS File and generates and Ast"
|
	
|
)
('as yet unclassified'
additiveExpression = (
	^super additiveExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#additive
		                                    first: first rest: rest ].
)

arguments = (
		^super arguments wrapper: [:lp :args :rp | flattenArguments: args  ].
)

array = (
	^super array wrapper: [:a | (a token at: 2)  ].
)

assignmentExpression = (
	^super assignmentExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#assign
		                                    first: first rest: rest ].
)

assignmentExpressionNoIn = (
	^super assignmentExpressionNoIn 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#assign
		                                    first: first rest: rest ].
)

binaryExpressionIdentifier: id = (     
	^(id respondsTo: #token) 
	    ifTrue: [id token]
	    ifFalse: [		   
		 String withAll:
		      (id inject: (OrderedCollection new) into: [:a :b |
			       a addLast:( (b respondsTo: #token) ifTrue: [b token]
			                             ifFalse: [b]
			                            ) .
			       a
			 ]).
		
		]
)

bitwiseANDExpression = (
	^super bitwiseANDExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitAnd
		                                    first: first rest: rest ].
)

bitwiseANDExpressionNoIn = (
	^super bitwiseANDExpressionNoIn 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitAnd
		                                    first: first rest: rest ].
)

bitwiseORExpression = (
	^super bitwiseORExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitOr
		                                    first: first rest: rest ].
)

bitwiseORExpressionNoIn = (
	^super bitwiseORExpressionNoIn
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitOr
		                                    first: first rest: rest ].
)

bitwiseXORExpression = (
	^super bitwiseXORExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitXor
		                                    first: first rest: rest ].
)

bitwiseXORExpressionNoIn = (
	^super bitwiseXORExpressionNoIn
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#bitXor
		                                    first: first rest: rest ].
)

block = (
	^super block 
	                  wrapper: [:lb :statements :rb |   
		                                TestingAstNode name: #block
		                                    contents: (statements asArray). ].
)

callExpression = (
		^super callExpression 
	                 wrapper: [:id :col | 
		                       flattenCallExpression: col from: id.
		                                           ].
)

complexUnaryExpression = (
	^super complexUnaryExpression 
	             wrapper: [:op :exp | 
		                  TestingAstNode 
		                           name: #unary 
		                           contents: { (op respondsTo: #token) 
		                                                     ifTrue: [op token]
		                                                     ifFalse: [op] . 
		                                            exp. }  ].
)

conditionalExpression = (
	^super conditionalExpression 
	                 wrapper: [:condition :col |   
		                             (col = nil) 
		                                 ifTrue: [condition]
		                                 ifFalse: [
                                                  TestingAstNode name: #conditional
		                                               contents: { condition. 
		                                                                 col at: 2. 
		                                                                 col at: 4. }]].
)

conditionalExpressionNoIn = (
	^super conditionalExpressionNoIn 
	                 wrapper: [:condition :col |   
		                             (col = nil) 
		                                 ifTrue: [condition]
		                                 ifFalse: [
                                                  TestingAstNode name: #conditional
		                                               contents: { condition. 
		                                                                 col at: 2. 
		                                                                 col at: 4. }]].
)

createNodeForBinaryExpression: type first: first rest: rest = (
	^rest inject: first into: [ 
			                         :current :next |
			                              TestingAstNode
			                                  name: type
			                                  contents: {  binaryExpressionIdentifier: (next at: 1)  " (next at: 1) token".
			                                                    current.
			                                                    next at: 2. }]
)

doStatement = (
	^super doStatement 
	                  wrapper: [:do :statement :while :lp :condition :rp :sc |   
		                               TestingAstNode name: #do
		                                  contents: { statement. condition }.]
)

equalityExpression = (
	^super equalityExpression 
	                 wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#equality
		                                    first: first rest: rest ].
)

equalityExpressionNoIn = (
	^super equalityExpressionNoIn
	                 wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#equality
		                                    first: first rest: rest ].
)

expression = (
	^super expression 
	                wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#comma
		                                first: first rest: rest ].
)

expressionNoIn = (
	^super expressionNoIn 
	                wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#comma
		                                first: first rest: rest ].
)

expressionStatement = (
	^super expressionStatement 
	                  wrapper: [:n :expression :sc |   
		                                TestingAstNode name: #expressionStatement
		                                    contents: { expression }. ].
)

flattenArguments: args = (
	|col| 
      
	^((args isNil not) and: [args size > 0 ])
           ifTrue: [
               col: OrderedCollection new.
	         col addLast: (args at: 1).
	         ((args at: 2) size > 0) ifTrue: [
		       (args at: 2) do: [:i | col addLast: (i at: 2) ].
		   ].
	         col asArray.
	     ]
           ifFalse: [ {} ].
)

flattenCallExpression:col from: initial = (
	|tmp|
	tmp: initial.
	col do: [ :i |
		   ((i class name) = #Array) ifTrue:[ tmp:: TestingAstNode  
			                                        name: #call 
			                                        contents: {tmp. i.}]
                 ifFalse: [
                          (((i at: 1) token) = $.) ifTrue:[ tmp:: TestingAstNode  
			                                        name: #memberAccess 
			                                        contents: {tmp. i at: 2.}].
                          (((i at: 1) token) = $[) ifTrue:[ tmp:: TestingAstNode  
			                                        name: #arrayAccess 
			                                        contents: {tmp. i at: 2.}].
		   ].
		 ].
	^tmp.

)

flattenCharCollectionToString: collection = (
    | newCollection |
    newCollection:: OrderedCollection new: (collection size).
    ^(String withAll: (flatteningCollectedString: collection to: newCollection))
)

flattenMemberExpression: col from: initial = (	
	|tmp|
	tmp: initial.
	col do: [ :i |
		   (((i at: 1) token) = $.) ifTrue:[ tmp:: TestingAstNode  
			                                        name: #memberAccess 
			                                        contents: {tmp. i at: 2.}].
	 	   (((i at: 1) token) = $[) ifTrue:[ tmp:: TestingAstNode  
			                                        name: #arrayAccess 
			                                        contents: {tmp. i at: 2.}].
		 ].
	^tmp.
)

flatteningCollectedString: collection to: newCollection = (
    collection do:
          [:value | 
	      #OrderedCollection = (value class name)
	          ifTrue: [ flatteningCollectedString: value to: newCollection ]
	          ifFalse: [value ~= nil ifTrue: [newCollection addLast: value]]].
    ^newCollection
)

forInStatement = (
	^super forInStatement 
	                  wrapper: [:for :lp :var :initial :in :col :rp :statement |   
		                               TestingAstNode name: #forIn
		                                  contents: {
		                                           TestingAstNode name: #vardeclarations contents: (initial  asArray).
		                                            col. statement. }.]
)

forInStatementNoVar = (
	^super forInStatementNoVar 
	                  wrapper: [:for :lp  :initial :in :col :rp :statement|   
		                               TestingAstNode name: #forIn
		                                  contents: {
 		                                            initial.
		                                            col. statement. }.]
)

forStatement = (
	^super forStatement 
	                  wrapper: [:for :lp :var :initial :sc1 :condition :sc2 :inc :rp :statement |   
		                               TestingAstNode name: #for
		                                  contents: {
		                                           TestingAstNode name: #vardeclarations contents: (initial  asArray).
		                                            condition. inc. statement. }.]
)

forStatementNoVar = (
	^super forStatementNoVar 
	                  wrapper: [:for :lp  :initial :sc1 :condition :sc2 :inc :rp :statement |   
		                               TestingAstNode name: #for
		                                  contents: {
 		                                            initial.
		                                            condition. inc. statement. }.]
)

functionexpression = (
	^super functionexpression wrapper:
	    [:fun :fname :lp :params :rp :lb :rb |  TestingAstNode name: #function
		                                contents: {fname. params. }].
)

getEscapedValue: collection <OrderedCollection> = (
     | result | 
     ((collection at: 2) = $n )
         ifTrue: [result:: string lf ]
         ifFalse:[result:: (collection at: 2) ].
     ^result
)

identifier  = (
	^super identifier wrapper: [:t :k |  (flattenCharCollectionToString: (k token  ))].
)

ifStatement = (
	^super ifStatement 
	                  wrapper: [:if :lp :condition :rp :thenStatement :elseCol |   
		                                (elseCol = nil)
		                                         ifTrue: [ TestingAstNode name: #if 
			                                                     contents: { condition. thenStatement.} ]
		                                         ifFalse: [ TestingAstNode name: #if 
			                                                     contents: { condition. 
			                                                                       thenStatement.
			                                                                       elseCol at: 2.} ]
		                         ].
)

logicalAndExpression = (
	^super logicalAndExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#and
		                                    first: first rest: rest ].
)

logicalAndExpressionNoIn = (
	^super logicalAndExpressionNoIn 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#and
		                                    first: first rest: rest ].
)

logicalOrExpression = (
	^super logicalOrExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#or
		                                    first: first rest: rest ].
)

logicalOrExpressionNoIn = (
	^super logicalOrExpressionNoIn 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#or
		                                    first: first rest: rest ].
)

memberexpression = (
	^super memberexpression 
	                  wrapper: [:id :col | 
		                                (col size = 0) 
		                                ifTrue: [ id]
                                            ifFalse: [ flattenMemberExpression:col from:id].
		                                           ].
)

messageSelector = (
	^ super variableStatement 
)

minusMinus = (
	^super minusMinus wrapper: [:m1 :m2 | '--' ].
)

multiplicativeExpression = (
	^super multiplicativeExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#multiplicative
		                                    first: first rest: rest ].
)

null = (
	^ super null wrapper: [:o | nil].
)

number = (
	^super number wrapper: [:o | Number readFrom: (flattenCharCollectionToString: (o token)) ].
)

object  = (
	^super object wrapper: 
	      [:obj | JSObject withContent: 
		               (Dictionary newFrom: ((obj token at: 2) collect: [:e | (e at: 1) -> (e at: 3)]))].
)

parse: input  = (
	^super value parse: input.
)

plusPlus = (
	^super plusPlus wrapper: [:p1 :p2 | '++' ].
)

postfixExpression = (
	^super postfixExpression 
	               wrapper: [:obj :post | 		                            
		                          post inject: obj into: [:o :i |
			                            TestingAstNode name: #postfix
			                                        contents: {
			                                             i at: 1.
			                                             o.
			                                        }.
			                    ] ]. 
)

relationalExpression = (
	^super relationalExpression 
	                 wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#relational
		                                    first: first rest: rest ].
)

relationalExpressionNoIn = (
	^super relationalExpressionNoIn 
	                 wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#relational
		                                    first: first rest: rest ].
)

shiftExpression = (
	^super shiftExpression 
	                  wrapper: [:first :rest |   
		                                createNodeForBinaryExpression:#shift
		                                    first: first rest: rest ].
)

simpleNewExpression = (
	^super simpleNewExpression 
	              wrapper: [:nt :mem :args | 
		                            TestingAstNode  
		                                      name: #new 
		                                      contents:{ mem. args.  } ].
)

simpleNewMemberExpression = (
	^super simpleNewMemberExpression  wrapper: [:a :b | TestingAstNode name: #new contents: { b. }].
"	           wrapper: [:a :b | ((a class name) = #OrderedCollection) 
		                             ifTrue: [TestingAstNode  
			                                        name: #new 
			                                        contents: {a at: 1. a at: 2.}] 
 	                                   ifFalse: [ a ]. ]"
)

string  = (
	^super string wrapper: 
	       [:t | flattenCollectedString: (t token at: 2)].
)

tAmpAmp = (
	^super tAmpAmp wrapper: [:f :s | '&&'].
)

tPipePipe = (
	^super tPipePipe wrapper: [:f :s | '||'].
)

this = (
	^super this wrapper: [:o | #this].
)

variableDeclaration = (
		^super variableDeclaration 
	                  wrapper: [:varName  :optionalInitialValue |   
		                                TestingAstNode name: #vardeclaration
		                                         contents: ((optionalInitialValue = nil) 
		                                                                 ifTrue: [{ varName.  }]
		                                                                 ifFalse: [{ varName. (optionalInitialValue at: 2)}]
		) ]
)

variableDeclarationNoIn = (
		^super variableDeclarationNoIn 
	                  wrapper: [:varName  :optionalInitialValue |   
		                                TestingAstNode name: #vardeclaration
		                                         contents: ((optionalInitialValue = nil) 
		                                                                 ifTrue: [{ varName.  }]
		                                                                 ifFalse: [{ varName. (optionalInitialValue at: 2)}]
		) ]
)

variableStatement = (
		^super variableStatement 
	                  wrapper: [:v :declarationList :sc |   
		                                TestingAstNode name: #vardeclarations 
		                                         contents: ( declarationList asArray  ) ]
)

whileStatement = (
	^super whileStatement 
	                  wrapper: [:while :lp  :condition :rp :statement |   
		                               TestingAstNode name: #while
		                                  contents: {
 		                                            
		                                            condition.  statement. }.]
)

'primitive'
tfalse = (
	^super tfalse   wrapper: [:f | false].
)

ttrue = (
	^super ttrue   wrapper: [:t | true].
)

'complex'
flattenCollectedString: collection = (
    | newCollection |
    newCollection:: OrderedCollection new: (collection size).
    collection do:
          [:value | 
	      #OrderedCollection = (value class name)
	          ifTrue: [ newCollection addLast: (getEscapedValue: value) ]
	          ifFalse: [newCollection addLast: value]].
    ^(String withAll: newCollection)
)

))